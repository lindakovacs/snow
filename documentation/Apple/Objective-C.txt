http://cocoadevcentral.com/d/learn_objectivec/
http://www.codeproject.com/Articles/88929/Getting-Started-with-iPhone-and-iOS-Development


http://habrahabr.ru/post/107126/
-----------------------------------------------------------------------------------------------------
ТИП ID

Все, создаваемые в Objective-С объекты классов должны размещатся в динамической памяти. Поэтому особое значение приобретает тип id,
который является указателем на объект любого класса (по сути void*). Нулевой указатель именуется константой nil.
Таким образом, указатель на любой класс можно привести к типу id. Возникает проблема: как узнать к какому классу относится объект, скрывающийся под id?
Это делается благодаря инварианту (ранее isa, сейчас возвращается self.class или [self class]), который присутствует в любом объекте класса, унаследовавшего специальный базовый клас NSObject.

Объекту типа id может быть присвоено любое объектное значение, и к типу id может быть приведен любой другой тип.
Значение типа id может быть использовано в любом присваивании там, где ожидается значение некоторого конкретного объектного типа.
Понятие назначения включает в себя передачу параметров; таким образом, значение типа id можно передать в качестве аргумента везде, rде ожидается параметр некоторого конкретного объектного типа.

NSObject - не единственный базовый хласс в каркасе Сосоа. Раньше это было так, но теперь есть и друrой базовый хласс, NSProxy, который используется только в особых обстоятельствах.

-----------------------------------------------------------------------------------------------------

Classes Are Blueprints for Objects. A class describes the behavior and properties common to any particular type of object.
Классы Чертежи для объектов. Класс описывает поведение и свойства, общие для любого конкретного типа объекта.

In Objective-C, the class interface specifies exactly how a given type of object is intended to be used by other objects.
In other words, it defines the public interface between instances of the class and the outside world.
В Objective-C, интерфейс класса указывает, как именно данный тип объекта предназначена для использования другими объектами.
Другими словами, он определяет общий интерфейс между экземплярами класса и внешним миром.

Some classes define objects that are immutable.
Некоторые классы определяют объекты, которые являются неизменными.

The Interface for a Class Defines Expected Interactions. Интерфейс класса определяет ожидаемое взаимодействие (поведение).

-----------------------------------------------------------------------------------------------------
http://virtualmind.ru/2012/03/19/properties-in-objective-c-in-deep/ о свойствах
https://habrahabr.ru/post/265175/
Атрибуты свойств в Objective-C.

Хорошим тоном при обращении к данным какого-либо объекта в объектно-ориентированных языках является использование методов сеттера и геттера (они же мутатор и акцессор).
Для начала поделим все атрибуты, которые есть у свойства, на группы:

- атрибуты доступности (readonly/readwrite),
- атрибуты владения (retain/strong/copy/assign/unsafe_unretained/weak),
- атрибут атомарности (atomic/nonatomic),
- nullability атрибут (null_unspecified/null_resettable/nullable/nonnull) — появился в xcode 6.3


-----------------------------------------------------------------------------------------------------
Use Accessor Methods to Get or Set Property Values

You access or set an object’s properties via accessor methods:
Используйте методы доступа для получения или установки значений свойств.
Вы получаете доступ к или установить свойства объекта с помощью методов доступа:

NSString *firstName = [somePerson firstName];
[somePerson setFirstName:@"Johnny"];

By default, these accessor methods are synthesized automatically for you by the compiler, so you don’t need to do anything other than declare the property using @property in the class interface.
По умолчанию эти методы доступа синтезируются автоматически для вас компилятором, так что вам не нужно делать ничего, кроме объявить свойство с помощью property в интерфейсе класса.
Если стоит readonly, то будет синтезирован толко геттер.

The synthesized methods follow specific naming conventions.
Синтезированные методы следуют конкретные соглашения об именах.

Note: The opposite of readonly is readwrite. There’s no need to specify the readwrite attribute explicitly, because it is the default.

Note: In general, property accessor methods should be Key-Value Coding (KVC) compliant, which means that they follow explicit naming conventions.
В общем, методы доступа к свойствам должен быть ключ-значение кодирования совместимый, что означает, что они следуют явные соглашения об именах.

Key-value coding is a mechanism for accessing an object’s properties indirectly, using strings to identify properties,
rather than through invocation of an accessor method or accessing them directly through instance variables.
In essence, key-value coding defines the patterns and method signatures that your application’s accessor methods implement.
Ключ-значение кодирования представляет собой механизм для доступа к свойствам объекта косвенно, используя строку, идентифицирующую свойства,
а не через вызове акцесора или доступ к ним непосредственно через переменные экземпляра.
В сущности, ключ-значение кодирования определяет закономерности и сигнатуры методов, что методы доступа вашего приложения реализуют.

The essential methods for key-value coding are declared in the NSKeyValueCoding Objective-C informal protocol and default implementations are provided by NSObject.
Существенные способы кодирования ключ-значение объявлены в NSKeyValueCoding Objective-C реализации неофициальные протоколов и по умолчанию, предоставленной NSObject.

Key-value coding supports properties with object values, as well as the scalar types and structs.
Non-object parameters and return types are detected and automatically wrapped, and unwrapped, as described in Scalar and Structure Support
Ключ-значение кодирования поддерживает свойства со значениями объектов, а также скалярных типов и структур.
Параметры Non-объекту и вернуться типов обнаруживаются и автоматически завернутый, и разворачивается, как описано в Scalar и опорная конструкция

!!! Using Key-Value Coding to Simplify Your Code

https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW4


Термин "переменная экземпляра" (instance variaЬle) встречается так часто, что его часто сокращают до ivar.

С другой стороны, если метода доступа не существует, но есть переменная экземпляра с тем же именем, что и ключ, будет выполнено непосредственное обращение к этой переменной
(даже если ее имя начинается с подчеркивания)! Такое непосредственное обращение нарушает закрытость переменных экземпляров, так что имеется способ отключения этой возможности для определенных
классов, если вы не хотите предоставления такоrо доступа. !!!Разобрать!!!
-----------------------------------------------------------------------------------------------------



https://habrahabr.ru/post/265175/
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------



-----------------------------------------------------------------------------------------------------
Automatic Reference Counting (ARC)

Начиная с 1 мая 2015 года новые приложения и обновления для компьютеров Mac, размещённые в Mac App Store, не могут пользоваться технологией Garbage Collection.
От неё начали отказываться ещё со времён запуска OS X Mountain Lion. Всё программное обеспечение следует перевести на Automatic Reference Counting (ARC) при помощи ассистента миграции в Xcode.
В приложениях может использоваться retain/release в ручном режиме

Garbage Collection – это устаревшая технология управления памятью. Она предусматривала периодическое удаление и очистку памяти компьютера от объектов, которые уже не нужны для работы с ПО.
Automatic Reference Counting, пришедший ему на смену, не запускает никаких фоновых процессов и не освобождает память – он компилирует код за программиста, расставляя retain/release.
http://www.enterra.ru/blog/garbage_collector_in_ios/

NSString* s = nil;
Небольшим, но очаровательным дополнением к возможностям механизма ARC является то, что такое присваивание выполняется автоматически, неявно и незаметно, в случае объявления 
переменной без ее инициализации:
NSString* s; // ARC присваивает s значение nil

Простое объявление экземпляра без инициализации устанавливает ссылку равной nil (при наличии механизма ARC) и многие методы каркаса Сосоа
преднамеренно возвращают nil как способ указать, что что-то пошло не так.

NSString* s = @"Hello, world!";
[s rockTheCasbah];
Класс NSString не имеет метода rockTheCasbah. До появления механизма ARC компилятор разрешил бы компиляцию этого кода, но предупредил бы о том, что вы сами ищете
себе проблемы. Однако при наличии механизма ARC компилятор с негодованием отвергает вашу попытку с сообщением о фатальной ошибке "No visiЬle @interface fог 'NSString' declares the selector 'rockTheCasbah'.

Немного замутив воду, мы можем проскользнуть мимо строгого механизма ARC. Предположим, что у нас есть класс MyClass, в котором объявлен метод rockTheCasbah. Тогда мы можем записать
MyClass* m = @"Hello, world!";
[m rockTheCasbah];
Мы говорим, что m - экземпляр класса MyClass, но на деле присваиваем этой ссылке экземпляр NSString. Это странное, но не строго запрещенное действие. Компилятор предупредит
нас о неполной корректности этого присваивания ("incompatiЬle pointer types"), но программу скомпилирует.

Ситуация нераспознанного селектора приводит к генерации исключения, внутреннего сообщения о том, что при работе программы произошло что-то плохое. Код на Objective-C может "поймать" исключение,
и тогда аварийное завершение не произойдет. Технически причина завершения работы программы не в том, что объекту оmравлено сообщение, с которым тот не смог справиться,
а в том, что не было перехвачено сгенерированное при этом исключение. Вот почему журнал сбоев может гласить "Terminating арр due to uncaught exception" (завершение приложения из-за неперехваченного исключения).

-----------------------------------------------------------------------------------------------------

ОТСУТСТВИЕ ПЕРЕГРУЗКИ
Тип данных, возвращаемых методом вместе с типами данных каждого из его параметров в порядке передачи этих параметров методу, составляют сшнатуру этого метода.
Существование двух методов одного и того же типа (метода класса или метода экземпляра) в одном и том же классе с одним и тем же именем недопустимо, даже если они имеют разные сигнатуры.

OVERRIDING
Замещениее (overriding). Совершенно естественное правило гласит, что если подкласс переопределяет метод, унаследованный от его суперкласса,
то когда соответствующее сообщение отправляется экземпляру этого подкласса, вызывается версия метода, определенная в подклассе.

КЛАССЫ

Простейший вариант:
@interface MyClass
@end
@implementation MyClass
@end

@interface MyClass : NSObject
- (NSString*) sayGoodnightGracie;
@end
@implementation MyClass {
// Здесь располагаются объявления переменных экземпляра
// для старого компилятора < LLVM 3.0, переменные размещались только в блоке интерфейса
}
- (NSString*) sayGoodnightGracie {
return @"Good night, Gracie!";
@end

-----------------------------------------------------------------------------------------------------

СЕКРЕТНАЯ ЖИЗНЬ КЛАССОВ

Один объект класса для каждого класса, определенного в вашей программе, создается автоматически при запуске программы.
Сюда входят и классы, импортируемые вашей программой, так что существует объект класса MyClass, поскольку вами определен MyClass, и объект класса NSString, поскольку
вы импортируете UIKit. h и весь каркас Сосоа. Именно этому объекту и посылаются сообщения, когда вы отправляете их имени класса.

"Голое" имя класса можно использовать только двумя способами:
Для отправки сообщения
В выражении [UIFont familyNames] сообщение familyNames отправляется имени UIFont.
Для указания типа экземпляра
В выражении NSString* имя NSString, за которым следует звездочка, определяет указатель на экземпляр этого класса.

Объект класса не является экземпляром, но он определенно представляет собой полноправный объект. Следовательно, объект класса можно использовать везде, где может использоваться объект.
Например, его можно присвоить переменной типа id:
id classObject = [MyClass class];

Затем вы можете вызвать метод класса, отправляя сообщение этому объекту, поскольку он является объектом класса:
id classObject = [MyClass class];
[classObject someClassMethod];

Все объекты класса являются также членами класса Class, так что вы можете написать следующий код:
Class classObject = [MyClass class];
[classObject someClassMethod];

-----------------------------------------------------------------------------------------------------
СОЗДАНИЕ ЭКЗЕМПЛЯРОВ(ИНСТАНСОВ) КЛАССА

1)
NSString* s2 = [s uppercaseString]; // косвенный способ

2)
SomeClass* aVariaЫe = [[SomeClass alloc] init]; // создание с нуля, вызов инициализатора (нельзя вызывать метод alloc сам по себе, необходимо немедленно вызвать другой метод, метод экземпляра,
который инициализирует вновь созданный экземпляр, вводит его в известное корректное состояние, так что ему могут отправляться другие сообщения)

NSArray* рер2 = [NSArray arrayWithArray: рер];
NSArray* рер2 = [[NSArray alloc] initWithArray: рер];

Часто бывает так, что встроенный класс каркаса Сосоа предлагает фабричный метод и инициализатор, которые, начиная с одного и того же типа данных, производят один и тот же результат.
В конечном счете нет никакой разницы, что именно вы используете; при одних и тех же аргументах оба подхода дают экземпляры, неотличимые друг от друга.
Эти два подхода имеют различные последствия для управления памятью. !!!Разобрать!!!
При использовании ARC эти различия, вероятно, не будут играть никакой роли.

[MyClass new] представляет собой синоним для [[MyClass alloc] init]

У класса должен быть один назначенный инициализатор. Назначенный инициализатор класса должен вызываться в процессе создания экземпляра класса. !!!Разобрать!!!
Если у класса имеется несколько инициализаторов, неважно, унаследованных или определенных в классе, назначенным инициализатором является инициализатор, от которого зависят другие инициализаторы: в конечном итоге они должны его вызывать.

3)
Создание экземnnяра кnасса на основе nib файла (сгенерированный из storyboard-фaйлa или хib-файла, в котором рисуются части пользовательского интерфейса)

outlet - переменная экземпляра, объявленная с помощью ключевого слова IBOutlet (этот макрос подсказывает IB, что эта переменная связана с объектом в nib-файле)

Пример:
@interface AppController : NSObject
{
}
@property (weak) IBOutlet NSArray *keywords;


https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Outlets/Outlets.html
outlet является свойством объекта, который ссылается на другой объект. Ссылка архивируется (сериализуется) посредством Interface Builder.

The connections between the containing object and its outlets are reestablished every time the containing object is unarchived from its nib file.
The containing object holds an outlet declared as a property with the type qualifier of IBOutlet and a weak option
Соединение между объектом и его outlet'ом восстановливается каждый раз, когда соответствующий объект десериализуется из nib файла.
Включающий его объект содержит outlet объявленный как свойство с типом классификатором IBOutlet и weak option.

But an outlet is more than a simple property. The connection between an object and its outlets is archived in a nib file; when the nib file is loaded, each connection is unarchived and reestablished,
and is thus always available whenever it becomes necessary to send messages to the other object.
Но outlet больше, чем простое свойство. Связь между объектом и его outlet сериализуется в файле nib; когда файл nib загружается, каждое соединение находящееся в архиве и повторно устанавливается,
и, таким образом, всегда доступно всякий раз, когда возникает необходимость отправки сообщений на другой объект.

An outlet is declared as a weak reference (weak) to prevent strong reference cycles.

Outlets are a form of object composition, which is a dynamic pattern that requires an object to somehow acquire references to its constituent objects so that it can send messages to them.

-----------------------------------------------------------------------------------------------------


-----------------------------------------------------------------------------------------------------

БЛОКИ !!!Разобрать!!!

Блок представляет собой расширение языка С, введенное в OS Х 10.6 и доступное начиная с iOS 4.0.
Это способ связывания некоторого кода в единую сущность и передачи его как аргумента функции С или методу Objective-C.

Возможно, наиболее примечательной возможностью блоков является следующая : переменные в области видимости в точке, где определен блок, сохраняют свои значения в блоке на
этот момент, даже несмотря на то, что блок может быть выполнен в некоторый более поздний момент. (Технически мы говорим, что блок является замыканием и что значения переменных
вне блока могут захватываться блоком. ) Этот аспект блоков делает их полезными для определения функциональности, которая будет выполнена в более позднее время или даже в
некотором другом потоке.


-----------------------------------------------------------------------------------------------------

Глобальное пространство имен

Определяя классы, для предотвращения конфликтов имен разумно выбирайте имена классов. В языке Objective-C нет пространства имен; есть одно огромное пространство имен, содержащее все имена.
Нежелательно, чтобы имя вашего собственного класса (или любое имя константы верхнего уровня) совпадало с именем, определенным в каркасе Сосоа. 
Вместо пространства имен имеется соглашение: каждый каркас Сосоа добавляет к именам в качестве префиксов определенную группу из прописных
букв (NSString и NSArray, CGFloat и CGRect и т.д.). Компания Apple предлагает вам также использовать свой собственный префикс.


-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
ИЗУЧИТЬ:

dispatch_once
dispatch_time
dispatch_after


-----------------------------------------------------------------------------------------------------




