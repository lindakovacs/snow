
--------------------------------------------------------------------------------------------------------------------------
https://habrahabr.ru/post/119877/
Определения

Замыкание (англ. closure) в программировании — функция, в теле которой присутствуют ссылки на переменные, объявленные вне тела этой функции в окружающем коде и не являющиеся её параметрами.
Замыкание связывает код функции с её лексическим окружением (местом, в котором она определена в коде). Лексические переменные замыкания отличаются от глобальных переменных тем, что они не занимают глобальное пространство имён.
От переменных в объектах они отличаются тем, что привязаны к функциям, а не объектам.

Блоки представляют собой анонимные функции, которые могут захватывать контекст (текущие стековое переменные и переменные-члены классов).
Блоки во время выполнения представляются объектами, они являются аналогами лямбда выражений в C++.

https://habrahabr.ru/company/e-Legion/blog/224363/
!!! Итак, можно сказать, что блок — это экземпляр особого класса (NSMallocBlock, NSGlobalBlock, NSStackBlock) который обязательно содержит ссылку (поле FuncPtr) на C функцию,
!!! являющуюся телом блока, и, опционально, переменные, захватываемые блоком.
!!! Все блоки (Global, Stack, Malloc) наследуются от базового NSBlock.

В OS X 10.6 и iOS 4.0 компания Apple анонсировала поддержку блоков, по сути являющиx собою замыкания.

Экземпляр блока, тип блока и сам блоковый литерал обозначаются с помощью оператора ^, пример:

typedef int (^MyBlock)(int);

int multiplier = 7;
MyBlock myBlock = ^(int num) {
 return num * multiplier;
};

Вызов блока аналогичен вызову обычной сишной функции. Например, так: myBlock(2)

Главной особенностью блоков является их умение хранить контекст в котором они создавались. 

--------------------------------------------------------------------------------------------------------------------------
Виды переменных контекста блока

1. Примитивные типы С и структуры, блоки хранят как константы. Пример:

int multiplier = 7;
int (^myBlock)(int) = ^(int num) {
  return num * multiplier;
};
multiplier = 8;
NSLog( @"%d", myBlock( 3 ) );

Печатает — 21, а не 24.

2. Переменные заданные с ключевым словом __block являются изменяемыми. Работает это за счет копирования значения такой переменной в кучу и каждый блок хранит ссылку на эту переменную. Пример:

__block int multiplier = 7;
int (^myBlock)(int) = ^(int num) {
  return num * multiplier;
};
multiplier = 8;
NSLog( @"%d", myBlock( 3 ) );

Печатает — 24, а не 21.

3. Переменные — указатели на обьекты с подсчетом ссылок (id, NSObject). Для них вызывается retain при копировании блока в кучу. Пример:

NSDate* date = [[NSDate alloc] init];

void (^printDate)() = ^() {
 NSLog( @"date: %@", date );
};

//копируем блок в кучу
printDate = [[printDate copy] autorelease];

[date release];
printDate();

4. Переменные — указатели на обьекты с подсчетом ссылок (id, NSObject) объявленые с ключевым словом __block. Для них НЕ вызывается retain при копировании блока в кучу.

Существует три вида блоков: глобальные(без состояния), локальные или они же стековые, и блоки в куче (MallocBlock).
Следовательно методы copy, retain, release и autorelease глобального блока ничего не делают. Метод retain так же ничего не делает для стекового блока.
Для Malloc блока метод copy в свою очередь работает как retain для NSObject

--------------------------------------------------------------------------------------------------------------------------
!!! Блоки и управление памятью

По умолчанию экземпляры блоков создаются не в куче, как можно было бы предположить, а в стеке. Поэтому при необходимости сделать отложеный вызов блока сначала его нужно скопировать в кучу.
Мы можем и вынуждены пользоватся методами класса NSObject — copy, retain, release и autorelease для блоков (вроде, устарело, с ARC нужно только copy).

https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxUsing.html#//apple_ref/doc/uid/TP40007502-CH5-SW6
Copying Blocks

Typically, you shouldn’t need to copy (or retain) a block. You only need to make a copy when you expect the block to be used after destruction of the scope within which it was declared. Copying moves a block to the heap.
You can copy and release blocks using C functions:
Block_copy();
Block_release();
To avoid a memory leak, you must always balance a Block_copy() with Block_release().

https://habrahabr.ru/post/209288/
Если в блоке используются методы класса, то желательно объявить слабую ссылку на self, чтобы избежать циклических ссылок.

--------------------------------------------------------------------------------------------------------------------------
https://habrahabr.ru/post/204356/
Objective-C++ (экзотика: особенности использования с лямбдами)

1. Мы можем присвоить блоку лямбду.
Пример
    void (^block_example)(int);
    auto lambda_example = [](int number){number++; NSLog(@"%d", number);};
    block_example = lambda_example;
    block_example(10); // log 11

2. Мы можем присвоить блок объекту std::function
Здесь стоит отметить что Objective-C и C++ имеют разные политики управления памятью, и хранение блока в std::function может приводить к «висячим» ссылкам.

3. Мы не можем присвоить лямбде блок.

--------------------------------------------------------------------------------------------------------------------------
https://habrahabr.ru/company/e-Legion/blog/224363/
Примечание

Не все знают, но в клэнге есть опция -rewrite-objc, которая преобразует код с Objective-C на C++.
clang -rewrite-objc -ObjC main.m -o out.cpp

Собственно, идея в том, чтобы используя эту опцию, понять, во что превращаются блоки.



